# Cursor Rules for Indexing Server

## Project Context

This is a FastAPI-based indexing server for vector embeddings and semantic search. The server integrates with:

- **Qdrant** as the vector database
- **Ollama** for local AI model inference (summarization and embeddings)
- **Poetry** for dependency management

## Technology Stack

- **FastAPI**: REST API framework
- **Qdrant**: Vector database for embeddings
- **Ollama**: Local LLM for text processing
- **Pydantic**: Data validation and settings
- **httpx**: Async HTTP client
- **Poetry**: Python dependency management

## Code Style & Standards

- Follow PEP 8 style guidelines
- Use async/await for all I/O operations
- Use Pydantic models for request/response validation
- Include proper error handling with HTTPException
- Add comprehensive docstrings for functions and classes
- Use type hints throughout the codebase
- Keep functions focused and single-responsibility

## Architecture Principles

- **Configuration**: All configurable values should be in `config.py` using Pydantic settings
- **Error Handling**: Use appropriate HTTP status codes and detailed error messages
- **Async Operations**: All external API calls (Ollama, Qdrant) should be async
- **Data Models**: Define clear Pydantic models for all API inputs/outputs
- **Logging**: Use structured logging for debugging and monitoring

## Key Files

- `app.py`: Main FastAPI application entry point and startup configuration
- `config.py`: Pydantic settings for configuration management
- `models.py`: Pydantic data models for API requests and responses
- `database.py`: Qdrant client setup and collection management
- `services.py`: Ollama service functions for embeddings and summarization
- `routes.py`: API route definitions and endpoint handlers
- `pyproject.toml`: Poetry dependencies and project metadata
- `.env`: Environment variables (not tracked in git)

## Architecture Organization

- **Separation of Concerns**: Each module has a specific responsibility
- **Models**: All Pydantic models centralized in `models.py`
- **Services**: External service integrations in `services.py`
- **Database**: Qdrant operations isolated in `database.py`
- **Routes**: API endpoints organized in `routes.py`
- **Configuration**: Settings management in `config.py`
- **Entry Point**: Clean application setup in `app.py`

## API Design

- RESTful endpoint design
- Use appropriate HTTP methods (GET, POST, PUT, DELETE)
- Include response models for documentation
- Group endpoints with tags for Swagger organization
- Return consistent error formats

## Development Workflow

1. Use Poetry for all dependency management: `poetry add <package>`
2. Run server with: `poetry run python3 app.py`
3. Test endpoints using FastAPI's automatic docs at `/docs`
4. Create `.env` file from the template in README
5. Ensure Qdrant and Ollama services are running

## External Dependencies

- **Qdrant**: Must be running on configured host:port
- **Ollama**: Must have required models installed:
  - `gemma2:2b` for text summarization
  - `nomic-embed-text` for embeddings

## Common Patterns

- Always use settings from `config.py` instead of hardcoded values
- Wrap external API calls in try-catch with proper error handling
- Use async context managers for HTTP clients
- Return appropriate HTTP status codes (200, 201, 400, 500, 503)
- Include metadata in embedding payloads (created_at, updated_at, file_id, file_path)

## Testing Strategy

- Test all endpoints with various input scenarios
- Verify error handling for external service failures
- Test with invalid inputs to ensure proper validation
- Use the `/docs` endpoint for interactive testing during development

## Performance Considerations

- Use async operations for all I/O
- Implement proper timeout values for external API calls
- Consider chunking large text inputs for embedding generation
- Use connection pooling for Qdrant client

## Security Notes

- Input validation through Pydantic models
- Proper error handling to avoid information leakage
- Consider rate limiting for production deployments
- Use environment variables for all configuration

## When Adding New Features

1. Update the appropriate Pydantic models if adding new fields
2. Add proper error handling and logging
3. Update the README documentation
4. Add relevant configuration options to `config.py`
5. Ensure async/await patterns are maintained
6. Test with the automatic API documentation

## Configuration System

- Pydantic settings with .env support
- All key settings are configurable (ports, models, database settings, logging)
- Structured logging with configurable levels and app name
- Environment-based configuration for deployment flexibility

## API Endpoints

- `POST /query` - Vector search with request body
- `POST/PUT /upsert` - Create or update file embeddings
- `DELETE /delete` - Remove file embeddings
- `GET /` - Health check endpoint

## Logging Standards

- Use the configured logger from settings
- Include contextual information (file_id, operation type)
- Log at appropriate levels:
  - INFO: Important operations and results
  - DEBUG: Detailed processing information
  - ERROR: Failures and exceptions
  - WARNING: Non-critical issues
- Use structured logging format with app name and timestamps

## Modular Development Patterns

- **Adding New Models**: Add to `models.py` and import in relevant modules
- **New Service Functions**: Add to `services.py` for external integrations
- **Database Operations**: Add to `database.py` for Qdrant-specific operations
- **New Endpoints**: Add to `routes.py` using the APIRouter pattern
- **Configuration Changes**: Update `config.py` and document in README
- **Cross-Module Dependencies**: Keep imports clean and avoid circular dependencies

## File Import Guidelines

- `app.py` imports from: config, database, routes
- `routes.py` imports from: config, database, models, services
- `services.py` imports from: config (minimal dependencies)
- `database.py` imports from: config (minimal dependencies)
- `models.py`: No internal imports (pure Pydantic models)
- `config.py`: No internal imports (pure configuration)
